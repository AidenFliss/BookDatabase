name: Manual Batch Add Books
on:
  workflow_dispatch:

jobs:
  batch-add-books:
    runs-on: ubuntu-latest
    permissions:
      issues: write
      contents: write

    steps:
      - name: Checkout repo
        uses: actions/checkout@v4

      - name: Process backlog of open book requests
        uses: actions/github-script@v7
        with:
          script: |
            const fs = require("fs");
            const { execSync } = require("child_process");
            const owner = context.repo.owner;
            const repo = context.repo.repo;

            console.log("Fetching all open issues...");
            const issuesResp = await github.rest.issues.listForRepo({
              owner,
              repo,
              state: "open",
              per_page: 100
            });
            const issues = issuesResp.data;

            if (!issues.length) {
              console.log("No open issues found.");
              return;
            }

            const bookListPath = "BookList.json";
            const versionPath = "Version.json";

            if (!fs.existsSync(bookListPath)) {
              console.log("BookList.json not found, aborting.");
              return;
            }

            let list;
            try {
              list = JSON.parse(fs.readFileSync(bookListPath, "utf8"));
            } catch (err) {
              console.log("Failed to parse BookList.json:", err);
              return;
            }

            const lastEmpty = list.pop(); // keep last empty entry

            let processedIssues = [];
            for (const issue of issues) {
              if (!issue.title.startsWith("[NEW BOOK]")) continue;

              const body = issue.body || "";
              const match = body.match(/```json([\s\S]*?)(?:```|$)/);
              if (!match) {
                console.log(`Skipping issue #${issue.number}: no JSON found.`);
                continue;
              }

              let book;
              try {
                book = JSON.parse(match[1].trim());
              } catch (err) {
                console.log(`Skipping issue #${issue.number}: invalid JSON.`);
                continue;
              }

              for (const k in book) {
                if (typeof book[k] === "string") {
                  book[k] = decodeURIComponent(book[k]);
                }
              }

              list.push(book);
              processedIssues.push(issue.number);
            }

            if (!processedIssues.length) {
              console.log("No valid book issues to process.");
              return;
            }

            list.push(lastEmpty);

            // Write back BookList.json
            fs.writeFileSync(bookListPath, JSON.stringify(list, null, 2) + "\n");

            // Increment Version.json once
            let versionData = { version: 1 };
            if (fs.existsSync(versionPath)) {
              try {
                versionData = JSON.parse(fs.readFileSync(versionPath, "utf8"));
                versionData.version = (versionData.version || 0) + 1;
              } catch {}
            }
            fs.writeFileSync(versionPath, JSON.stringify(versionData, null, 2) + "\n");

            // Commit changes
            execSync("git config user.name 'github-actions[bot]'");
            execSync("git config user.email '41898282+github-actions[bot]@users.noreply.github.com'");
            execSync(`git add ${bookListPath} ${versionPath}`);
            execSync(`git commit -m "Batch add ${processedIssues.length} books, version ${versionData.version}"`);
            execSync("git push");

            console.log(`Processed issues: ${processedIssues.join(", ")}`);

            // Close all processed issues
            for (const number of processedIssues) {
              await github.rest.issues.update({
                owner,
                repo,
                issue_number: number,
                state: "closed"
              });
            }

            console.log(`Closed ${processedIssues.length} issues and updated version.json.`);
